# Ory Sandbox

This project provides a sandbox for working with the Ory IAM stack, as well as a few toy Elixir/Phoenix project (`hello_ory`, `user_service`) that demonstrate basic functionality of this stack.

This project contains a few different items:
  - A Compose service that is used to run the Ory stack applications (Hydra, Kratos)
  - An Elixir project (`hello_ory`) that demonstrates a basic machine-to-machine auth workflow (using Hydra)
  - A Phoenix application (`user_service`) that demonstrates a basic user authentication workflow (using Kratos; currently has very limited functionality)

## Quickstart

> NOTE: All commands in this README should be run from the project root directory, unless otherwise specified.

### Start the Ory applications

- Run `docker compose up`.
  - This will start the following services:
    - Ory Kratos
    - Ory Hydra
  - Wait a few seconds for the migrations to finish running.

> TIP: The configuration for the Ory services is located in the directory `./volumes/config/`.

### Configure the Elixir client/server

Run `./create-client-credentials-grant.sh` twice to create two OAuth client ID/secret pairs. (One for the Elixir HTTP server, and one for our Elixir IEx "client".)

The data generated by this script must be used in the `hello_ory` Elixir project config.

To configure the Elixir project, you can use one of two strategies (the first method is preferred since it will not modify any files that are committed to the Git repo):
  1. Configure the Elixir project using direnv
  2. Configure the Elixir project by modifying the runtime config file directly

#### Configure the Elixir project using direnv

- Enable direnv in the Elixir project directory: `cd ./hello_ory`

- Copy the client ID and secret into `./hello_ory/.env`:

`./hello_ory/.env`
```
CLIENT_OAUTH_CLIENT_ID=your_elixir_client_oauth_client_id
CLIENT_OAUTH_CLIENT_SECRET=your_elixir_client_oauth_client_secret

SERVER_OAUTH_CLIENT_ID=your_elixir_server_oauth_client_id
SERVER_OAUTH_CLIENT_SECRET=your_elixir_server_oauth_client_secret
```

#### Configure the Elixir project by modifying the runtime config file directly

If you don't want to use direnv, you can copy your generated client ID/secret pairs directly into `./hello_ory/config/runtime.exs` instead (NOTE: Using this strategy may clobber your Git history if future changes are made to the upstream repo):

`./hello_ory/config/runtime.exs`
```elixir
config :hello_ory, :client,
  oauth_client_id: "your_elixir_client_oauth_client_id",
  oauth_client_secret: "your_elixir_client_oauth_client_secret",

config :hello_ory, :server,
  oauth_client_id: "your_elixir_server_oauth_client_id",
  oauth_client_secret: "your_elixir_server_oauth_client_secret"
```

### Run the Hydra (machine-to-machine auth) demo

- Navigate to the Elixir project directory: `cd ./hello_ory`

- Enable direnv for this directory to activate the dotenv variables: `direnv allow` (This step can be skipped if you edited the runtime config files directly.)

- Fetch and install the Elixir dependencies: `mix deps.get`

- Start the Elixir client and HTTP server (they both run simultaneously in the same shell session): `iex -S mix`
  - The Elixir HTTP server runs in the background and responds to HTTP requests on the configured port (default: 8000).
  - The IEx "client" consists of the actions performed in the IEx shell.

> NOTE: Although the client and server are both running together, the real authentication/authorization process is still required for the server to send a successful response to the client.

- Perform the following actions in the client (IEx shell):

```elixir
# Sanity check: The unprotected URL route always works, even without a token
iex> HelloOry.send_request_to_unprotected_endpoint()
{:ok, %Req.Response{status: 200, body: "Hello, world!\n"}}

# Attempt to access the protected endpoint with an invalid token. (The request should return 401)
iex> HelloOry.send_request_to_protected_endpoint("invalid-token")
{:ok, %Req.Response{status: 401, body: "401 Unauthorized\n"}}

# Get a valid access token from Hydra
iex> token = HelloOry.get_access_token_for_elixir_client()
"ory_at_0000000000000000000000000000000000000000000.0000000000000000000000000000000000000000000"

# The protected endpoint can be accessed when using a valid token
iex> HelloOry.send_request_to_protected_endpoint(token)
{:ok, %Req.Response{status: 200, body: "401 Unauthorized\n"}}
```

That's it! This demonstrates how Ory Hydra can be used to authenticate and authorize machine-to-machine requests to a protected endpoint.

#### What validations are being performed?

The Elixir HTTP server performs the following validations on the access token that it receives:
  - The token is valid and not expired (according to Hydra)
  - The token comes from the expected client ID
  - The token specifies the correct "audience" (`"my-server"`)
  - The token specifies the correct "scope" (`"secrets:read"`)

#### Digging deeper

For more information, see the module documentation for the `HelloOry` project in IEx:

```elixir
iex> h HelloOry
```

You may also check out the contents of the `hello_ory` Elixir project to see how things work under the hood.

The project itself is quite simple. Most of the code is contained in the following files:

- `./hello_ory/lib/hello_ory.ex`
- `./hello_ory/lib/hello_ory/router.ex`

### Run the Kratos (user management) demo

> NOTE: This project is not currently very far along, and only implements a Kratos user registration workflow (no login).

- Start from the repo root directory.

- Ensure the Compose service has been started (the same one from before): `docker compose up`

- Navigate to the Phoenix user management project: `cd ./user_service/`

- Fetch and install the Elixir dependencies: `mix deps.get`

- Start the Phoenix server: `iex -S mix phx.server`

- In a web browser, navigate to `http://127.0.0.1:4000`.
  - NOTE: **Do not** use `localhost:4000`! For this project, Ory is configured for use with `127.0.0.1`, which is a different origin than `localhost`. Credentials cannot be shared between these two origins.

- Complete the registration form.
  - Any errors (e.g. short password, unavailable username) will be returned to the Phoenix server, and will be rendered in the template.

- After successful registration, the browser will display the text "Registration completed successfully".

- That's the whole demo so far.
